# Java关键技术

##### 1、Java中sleep()与wait()的区别

- sleep()方法是Thread线程类的方法，让正在执行的线程主动让出CPU，在sleep指定的时间后CPU再回到该线程，**但是sleep方法不会释放同步资源锁**。
- wait()方法是Object类的方法，当前线程让自己暂时退让出同步资源锁，只有调用了notify()方法，之前调用wait()的线程才会解除wait状态。



##### 2、JVM内存分布

- **栈内存**
  - 栈帧 - 只有在调用一个方法时，才为当前栈分配一个帧，然后将该帧压入栈。
  - 帧中存储了对应方法的局部数据，方法执行完，对应的帧则从栈中弹出，并把返回结果存储在**调用方法的帧的操作数栈中**。
  - 栈是线程私有的。
  - Stack栈内存是用来存储函数的主体和变量名的。Java中的代码是在函数体中执行的，每个函数的主体都会被放在栈内存中。因为栈是先进后出的，所以最晚调用的函数会最先出栈。
- **堆内存**
  - 每一个JVM实例唯一对应一个堆
  - 存放类实例或者数组，并由应用所有的线程共享
  - 堆内存是用来存储实例的，例如People people = new People(),people 是存储在栈stack内存中的，实例化后的对象实体是存在堆heap内存中的。栈内存中存储的people存储着指向堆内存的地址。堆内存的存在是为了更好的管理内存，实现Garbage Colloection。当people不再指向堆内存中的实例的时候，GC机制就会把堆heap内存中的实例删除，释放内存。
- **程序计数器**
  - 线程私有，生命周期与线程相同。
  - 



##### 3、HashMap

- HashMap的Key/Value均可以为null，而HashTable的Key/Value均不可为null。

- HashMap的初始容量是16，这与HashMap的位运算有关。index = HashCode (key)  & (Length -  1)
- HashMap扩容要求容量必须是2的幂，因为这样二进制运算之后该Length为1111......这样与运算就只取决于Key的HashCode的值的最后几位，符合Hash均匀分布的原则。
- 在现在的JDK中，key hash之后还要右移16位，再与原数做一个异或，再做按位&与运算，以进一步减少碰撞。
- 在Java 8之前是链表，Java 8中换成了红黑树，让时间复杂度从O(n)变成了O(logn)
- Capacity - 当前容量 LoadFactor - 负载因子
- ReHash：当HashMap扩容之后，长度扩大，运算结果不同。
- 通过hash的方法，通过put和get存储和获取对象。存储对象时，我们将K/V传给put方法时，它调用hashCode计算hash从而得到bucket位置，进一步存储，HashMap会根据当前bucket的占用情况自动调整容量(超过`Load Facotr`则resize为原来的2倍)。获取对象时，我们将K传给get，它调用hashCode计算hash从而得到bucket位置，并进一步调用equals()方法确定键值对。如果发生碰撞的时候，Hashmap通过链表将产生碰撞冲突的元素组织起来，在Java 8中，如果一个bucket中碰撞冲突的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高速度。
- 高并发下的HashMap：

  - HashMap不是线程安全的

  - 用HashTable、Collections.synchronizedMap或者ConcurrentHashMap
  - HashTable、Collections.synchronizedMap都会给整个集合加锁，影响性能
  - ConcurrentHashMap - 兼顾了线程安全和运行效率
    - Segment分段操作（二级哈希表）
    - 锁分段技术 - segment之间互不影响
    - 不同segment、同一segment的一写一读可以并发执行
    - ReSize - 嵌套循环
      - 遍历所有segment，把segment下的元素数量累加起来
      - 把segment的修改次数累加起来
      - 如果segment的修改次数大于上一次总修改次数，重新统计，尝试次数+1
      - 如果尝试次数超过阈值，则对每一个Segment加锁，再重新统计
      - 再次判断修改次数
      - 释放锁，统计结束



##### 4、try、catch、finally

- try -- 用于监听。将要被监听的代码(可能抛出异常的代码)放在try语句块之内，当try语句块内发生异常时，异常就被抛出。
- catch -- 用于捕获异常。catch用来捕获try语句块中发生的异常。
- finally -- finally语句块总是会被执行。它主要用于回收在try块里打开的物理资源(如数据库连接、网络连接和磁盘文件)。只有finally块，执行完成之后，才会回来执行try或者catch块中的return或者throw语句，如果finally中使用了return或者throw等终止方法的语句，则就不会跳回执行，直接停止。



##### 5、深拷贝、浅拷贝

- **浅拷贝：**浅拷贝会创建一个新对象，这个对象有着原始对象属性的一份拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型（内存地址），拷贝的就是内存地址，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。
- **深拷贝：**深拷贝会拷贝所有的属性，并拷贝属性指向的动态分配的内存。



##### 6、Java中的引用类型

- 强引用（Strong Reference）

  普遍存在，类似 Object obj = new Object() 这类的引用，只要强引用存在，即使抛出 OutOfMemory错误也不会回收这种对象。

- 软引用（Soft Reference)

  用来描述一些有用但不是必须的对象，只有在内存不足的时候JVM才会回收这类对象，这个特性一般用来实现缓存：比如网页缓存、图片缓存等。（用于Bitmap等）

- 弱引用（WeakReference）

  用来描述非必需对象，当JVM进行垃圾回收时，无论内存是否充足，都会回收弱引用关联的对象。用于Handler中持有Activity的弱引用防止内存泄漏。

- 虚引用（PhantomReference）

  不影响对象的生命周期，在任何时候都可能被垃圾回收器回收



##### 7、Object中有什么方法

- equals
- hashCode
- clone
- toString
- notify
- notifyAll
- wait



##### 8、Java基本类型（8种，6+1+1）

- **数**
  - byte 8位，1字节
  - short 16位，2字节
  - int 32位，4字节
  - long 64位，8字节
  - float单精度浮点 32位，4字节
  - double 双精度浮点 64位，8字节
  - boolean 8位，1字节
  - char 16位，2字节



##### 9、Java异常处理

![img](https://www.runoob.com/wp-content/uploads/2013/12/12-130Q1234I6223.jpg)

整体分为三种：

- 运行时异常/非检查异常(RuntimeException)：

  如NullPointerException等，编译器不会检查，运行时报错。

- 非运行时异常/检查异常：

  如IOException，不处理就不会编译通过。

- 错误(Error):

  检查不到的，脱离控制的问题，如StackOverFlow。



**10、接口和抽象类**

- 抽象类和接口都不能被<b>直接</b>实例化，如果二者要实例化，就涉及到多态，如果抽象类要实例化，那么抽象类定义的变量必须指向一个子类对象，这个子类<b>继承</b>了这个抽象类并实现了这个抽象类的<b>所有</b>抽象方法。如果接口要实例化，那么这个接口定义的变量要指向一个子类对象，这个子类必须实现了这个接口所有的方法。
- 抽象类要被子类继承，接口要被子类实现。
- 接口里面只能对方法进行声明，抽象类既可以对方法进行声明也可以对方法进行实现。
- 抽象类里面的抽象方法必须全部被子类实现，如果子类不能全部实现，那么子类必须也是抽象类。接口里面的方法也必须全部被子类实现，如果子类不能实现那么子类必须是抽象类。
- 接口里面的方法只能声明，不能有具体的实现。这说明接口是设计的结果，抽象类是重构的结果。
- 抽象类里面可以没有抽象方法。
- 如果一个类里面有抽象方法，那么这个类一定是抽象类。
- 抽象类中的方法都要被实现，所以抽象方法不能是静态的static，也不能是私有的private。
- 接口（类）可以继承接口，甚至可以继承多个接口。但是类只能继承一个类。
- 抽象级别（从高到低）：接口&gt;抽象类&gt;实现类。
- 抽象类主要是用来抽象类别，接口主要是用来抽象方法功能。当你关注事物的本质的时候，请用抽象类；当你关注一种操作的时候，用接口。
- 抽象类的功能应该要远多于接口，但是定义抽象类的代价较高。因为高级语言一个类只能继承一个父类，即你在设计这个类的时候必须要抽象出所有这个类的子类所具有的共同属性和方法；但是类（接口）却可以继承多个接口，因此每个接口你只需要将特定的动作方法抽象到这个接口即可。也就是说，接口的设计具有更大的可扩展性，而抽象类的设计必须十分谨慎。
- 接口中**继承**接口用extends,可以继承多个接口。



**11、自动装箱、拆箱**

- 装箱过程是通过调用包装器的valueOf方法实现的，而拆箱过程是通过调用包装器的 xxxValue方法实现的。（xxx代表对应的基本数据类型）

- **缓存池** - 对于很多基本类型，都提供了缓存池，因此 Integer i1 = 100, Integer i2 = 100, 

  ​					=> i1 == i2 => true。整型的默认缓存池从-127~128



**12、Volatile**

- 避免指令重排
  - 如果线程 A **写入**一个 `volatile` 变量，之后线程 B 读取该变量，则线程 A 写入该变量之前线程就可见（定义的、修改的）的所有变量都将对线程 B 可见。JVM 会强制将缓存中的这些变量写入内存中。
  - 如果线程 A **读取**一个 `volatile` 变量，则读取该变量之前线程 A 可见的所有变量都会从内存中重新读取。