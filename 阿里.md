# 阿里

### （1）

##### 1、HashMap源码

  HashMap是基于哈希表(散列表)，实现Map接口的双列集合，数据结构是“链表散列”，也就是数组+链表 ，key唯一的value可以重复，允许存储null 键null 值，元素无序。

- **哈希冲突**

  如果两个不同的元素，通过哈希函数得出的实际存储地址相同怎么办？也就是说，当我们对某个元素进行哈希运算，得到一个存储地址，然后要进行插入的时候，发现已经被其他元素占用了，其实这就是所谓的哈希冲突，也叫哈希碰撞。

  - 开放定址法

  - 再散列函数法

  - 链地址法（数组+链表）

    ![](https://upload-images.jianshu.io/upload_images/5459476-a4fe2584887e6eb7.png)

  HashMap的底层就是一个数组，数组中每一项又是一个链表，当新建一个HashMap时候，就会初始化一个数组，查看源码如下，直接看重点，table = new Entry[capacity];   创建一个Entry数组，也就是上面的table ,这个Entry结构就是static的包含key value 还有一个next的指针，指向下一个元素的引用，也就构成了链表。

- 构造函数

  - HashMap()

    无参构造方法，初始容量16，负载因子0.75

  - HashMap(int initialCapacity)

    传入初始容量，负载因子0.75

- 扩容

  - 通过HashMap源码可以看到是在put操作时，即向容器中添加元素时，判断当前容器中元素的个数是否达到阈值（当前数组长度乘以加载因子的值）的时候，就要自动扩容了。
  - 重新计算容量；而这个扩容是计算出所需容器的大小之后重新定义一个新的容器，将原来容器中的元素放入其中。

- HashMap为什么是线程不安全的？

  - put的时候导致的多线程数据不一致

    比如有两个线程A和B，首先A希望插入一个key-value对到HashMap中，首先计算记录所要落到的 hash桶的索引坐标，然后获取到该桶里面的链表头结点，此时线程A的时间片用完了，而此时线程B被调度得以执行，和线程A一样执行，只不过线程B成功将记录插到了桶里面，假设线程A插入的记录计算出来的 hash桶索引和线程B要插入的记录计算出来的 hash桶索引是一样的，那么当线程B成功插入之后，线程A再次被调度运行时，它依然持有过期的链表头但是它对此一无所知，以至于它认为它应该这样做，如此一来就覆盖了线程B插入的记录，这样线程B插入的记录就凭空消失了，造成了数据不一致的行为。

  - 